class Queue:
    def __init__(self, capacity=100):
        # ساخت یک صف خطی با ظرفیت مشخص
        self.capacity = capacity
        self.items = [None] * capacity
        self.front = -1
        self.rear = -1

    def enqueue(self, value):
        # اگر صف پر باشد
        if self.rear == self.capacity - 1:
            print("Queue is Full")
            return
        
        # اگر صف خالی باشد
        if self.front == -1:
            self.front = 0
            self.rear = 0
            self.items[self.rear] = value
            return
        
        # حالت عادی
        self.rear += 1
        self.items[self.rear] = value

    def dequeue(self):
        # اگر صف خالی باشد
        if self.front == -1:
            print("Queue is Empty")
            return
        
        removed = self.items[self.front]

        # اگر آخرین عنصر حذف شود
        if self.front == self.rear:
            self.front = -1
            self.rear = -1
            return removed
        
        # حالت عادی
        self.front += 1
        return removed

    def show(self):
        # نمایش عناصر صف
        if self.front == -1:
            print("Queue is Empty")
            return
        
        for i in range(self.front, self.rear + 1):
            print(self.items[i], end=" ")
        print()


----------------------------

class QueueD:
    def __init__(self,k):
        self.k = k
        self.queue = [None]*k
        self.front = -1
        self.rear  = -1

    def display(self):
        if self.front == -1:
            print("nothing to show")
        else:
            i = self.front
            while True:
                print(self.queue[i], end=" ")
                if i == self.rear:
                    break
                i = (i + 1) % self.k

    def enqueue(self,data):
        if (self.rear+1) % self.k == self.front:
            print("its full")
        elif self.front == -1:
            self.front = 0
            self.rear = 0
            self.queue[self.rear] = data

        else:
            self.rear = (self.rear+1) % self.k
            self.queue[self.rear] = data

    def dequeue(self):
        if self.front == -1:
            print("already empty")
        elif self.front == self.rear:
            t = self.queue[self.front]
            self.front = -1
            self.rear= -1
            return t
        
        else:
            t = self.queue[self.front]
            self.front = (self.front+1)% self.k
            return t



    def display(self):
        if self.front == -1:
            print("nothing to show")
        else:
            i = self.front
            while True:
                print(self.queue[i], end=" ")
                if i == self.rear:
                    break
                i = (i + 1) % self.k
-----------------------------

class Stack:
    def __init__(self, capacity=1000):
        # ایجاد یک پشته با ظرفیت مشخص
        self.capacity = capacity
        self.data = []   # لیست داخلی برای نگهداری عناصر

    def push(self, value):
        # بررسی پر بودن پشته
        if len(self.data) >= self.capacity:
            print("Stack is Full")
            return -1
        
        # افزودن عنصر جدید
        self.data.append(value)

    def pop(self):
        # بررسی خالی بودن پشته
        if len(self.data) == 0:
            print("Stack is Empty")
            return -1
        
        # حذف و بازگرداندن آخرین عنصر
        return self.data.pop()

    def peek(self):
        # بررسی خالی بودن پشته
        if len(self.data) == 0:
            print("Stack is Empty")
            return -1
        
        # مشاهدهٔ آخرین عنصر بدون حذف
        return self.data[-1]

    def is_empty(self):
        # بررسی اینکه پشته خالی است یا نه
        return len(self.data) == 0

    def size(self):
        # تعداد عناصر موجود در پشته
        return len(self.data)
---------------------------------

class Nude:
    def __init__(self, data):
        self.data = data
        self.next = None

class Linklist:
    def __init__(self):
        self.head = None
    
    def  display(self):
        t = self.head
        while t != None:
            print(t.data, end= "->")
            t = t.next
        print("Null")
    
    def Instart(self,newdata):
        n = Nude(newdata)
        n.next = self.head
        self.head = n
    
    def Inend(self,newdata):
        n = Nude(newdata)
        if self.head is None:
            self.head = n
            return
        t = self.head
        while(t.next):
            t = t.next
        t.next = n
    
    def Inafter(self,m,newdata):
        if m is None:
            return
        n = Nude(newdata)
        n.next = m.next
        m.next = n


    def RemoveNude(self,key):
        t = self.head

        if t is not None:
            if(t.data == key):
                self.head = t.next
                t = None
                return
        p = None
        while t is not None:
            if t.data == key:
                break

            p = t
            t = t.next

        if t == None:
            return
        
        p.next = t.next
        t = None
=============================

class Node:
    def __init__(self,data):
        self.data = data
        self.next = None
        self.prev = None

class dlinklist:
    def __init__(self):
        self.head = None

    def instart(self,data):
        n = Node(data)
        n.next = self.head
        if self.head is not None:
            self.head.prev = n
        self.head = n


    def inend(self,V):
        n = Node(V)
        if self.head is None:
            self.head = n
            return
        t = self.head
        while t.next is not None:
            t = t.next
        t.next = n
        n.prev = t

    def inafter(self,x,d):
        n = Node(d)
        n.next = x.next
        x.next = n
        n.prev = x
        if n.next is not None:
            n.next.prev = n

    def delete(self, data):
        t = self.head

        # Case 1: empty list
        if t is None:
            return

        # Case 2: delete head
        if t.data == data:
            # only one node
            if t.next is None:
                self.head = None
                return
            # more than one node
            self.head = t.next
            self.head.prev = None
            t.next = None
            return

        # Case 3: delete middle or last
        while t is not None and t.data != data:
            t = t.next

        if t is None:
            return

        # Case 4: delete last node
        if t.next is None:
            t.prev.next = None
            t.prev = None
            return

        # Case 5: delete middle node
        t.prev.next = t.next
        t.next.prev = t.prev
        t.next = None
        t.prev = None
==========================

def bfs_traverse(graph, start):
    # اجرای BFS از یک رأس مشخص
    queue = [start]
    visited = set([start])

    while queue:
        current = queue.pop(0)

        # بررسی همسایه‌ها
        for neighbor in graph[current]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

    return visited


def dfs_traverse(graph, start, visited=None):
    # اجرای DFS با استفاده از بازگشت
    if visited is None:
        visited = set()

    visited.add(start)

    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs_traverse(graph, neighbor, visited)

    return visited
----------------------------
def selection_sort(arr):
    # ایجاد یک لیست خروجی با همان اندازه
    result = [None] * len(arr)
    temp = arr[:]  # کپی از آرایه اصلی برای جلوگیری از تغییر مستقیم

    for i in range(len(temp)):
        # پیدا کردن کوچک‌ترین مقدار
        smallest = float("inf")
        index = -1

        for j in range(len(temp)):
            if temp[j] < smallest:
                smallest = temp[j]
                index = j

        # قرار دادن کوچک‌ترین مقدار در خروجی
        result[i] = smallest
        temp[index] = float("inf")  # حذف منطقی کوچک‌ترین مقدار

    return result
----------------------------

# بخش n^2 → سه دستور داخل دو حلقه
for i in range(n):
    for j in range(n):
        x = i + j
        y = x * 2
        z = y - i

# بخش n → چهار دستور داخل یک حلقه
for k in range(n - 2):
    a = b
    b = c
    c = d
    d = e
--------------------------------
# شروع الگوریتم: مقدار n باید بزرگ‌تر از 1 باشد
while n > 1:
    # در هر مرحله مقدار n نصف می‌شود
    # این کار باعث کاهش سریع اندازه ورودی می‌شود
    n = n // 2

# پایان حلقه زمانی است که n به 1 یا کمتر برسد
-------------------------------
                                Have a nice day



        

        

        
            
                

         
        






        
        
        

        

    




